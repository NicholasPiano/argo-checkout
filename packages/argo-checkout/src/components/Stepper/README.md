# Stepper
## Props
required = *
<table><tr><th>Name</th><th>Type</th><th>Description</th></tr><tr><td>id</td><td><code>string</code></td><td>A unique identifier for the field. When no `id` is provided, a globally unique value will be used instead. </td></tr><tr><td>name</td><td><code>string</code></td><td>An identifier for the field that is unique within the nearest containing `&lt;Form /&gt;` component. </td></tr><tr><td>label*</td><td><code>string</code></td><td>Holding the quantity inside the stepper field </td></tr><tr><td>value</td><td><code>number</code></td><td>Current value for the field. If omitted, the field will be empty. You should update this value in response to the `onChange` callback on a text field. </td></tr><tr><td>max</td><td><code>number</code></td><td>The highest number that can be inputted in the stepper field </td></tr><tr><td>min</td><td><code>number</code></td><td>The lowest number that can be inputted in the stepper field  @default 0 </td></tr><tr><td>step</td><td><code>number</code></td><td>The amount the number can increase or decrease by  @default 1 </td></tr><tr><td>required</td><td><code>boolean</code></td><td>Whether the field needs a value. This requirement adds semantic value to the field, but it will not cause an error to appear automatically. If you want to present an error when this field is empty, you can do so with the `error` prop. </td></tr><tr><td>error</td><td><code>string</code></td><td>An error label to present with the field. </td></tr><tr><td>onFocus</td><td><code>() => void</code></td><td>Callback when input is focused. </td></tr><tr><td>onBlur</td><td><code>() => void</code></td><td>Callback when focus is removed. </td></tr><tr><td>onChange</td><td><code>(value: string) => void</code></td><td>Callback when the buyer has **finished editing** a field. Unlike `onChange` callbacks you may be familiar with from Polaris or other React component libraries, this callback is **not** run on every change to the input. Text fields are “partially controlled” components, which means that while the buyer edits the field, its state is controlled by the component. Once the buyer has signalled that they have finished editing the field (typically, by blurring the field), `onChange` is called if the input actually changed from the most recent `value` property. At that point, you are expected to store this “committed value” in state, and reflect it in the text field’s `value` property.This state management model is important given how Argo renders UI. Argo components run on a separate thread from the UI, so they can’t respond to input synchronously. A pattern popularized by [controlled React components](https://reactjs.org/docs/forms.html#controlled-components) is to have the component be the source of truth for the input `value`, and update the `value` on every user input. The delay in responding to events from an Argo extension is only a few milliseconds, but attempting to strictly store state with this delay can cause issues if a user types quickly, or if the buyer is using a lower-powered device. Having the UI thread take ownership for “in progress” input, and only synchronizing when the user is finished with a field, avoids this risk. * * It can still sometimes be useful to be notified when the user makes any input in the field. If you need this capability, you can use the `onInput` prop. However, never use that property to create tightly controlled state for the `value`. * * This callback is called with the current value of the field. If the value of a field is the same as the current `value` prop provided to the field, the `onChange` callback will not be run. </td></tr></table>